{"meta":{"title":"Cwiyc","subtitle":"流水不争先 争的是滔滔不绝","description":"争的是滔滔不绝","author":"Cwiyc","url":"https://cwiyc.top","root":"/"},"pages":[{"title":"书单","date":"2022-04-18T15:44:08.000Z","updated":"2022-04-18T16:17:38.244Z","comments":false,"path":"books/index.html","permalink":"https://cwiyc.top/books/index.html","excerpt":"","text":""},{"title":"404","date":"2022-04-06T10:48:47.872Z","updated":"2022-04-06T10:48:47.872Z","comments":true,"path":"404.html","permalink":"https://cwiyc.top/404.html","excerpt":"","text":"404"},{"title":"About me","date":"2022-04-06T15:44:08.000Z","updated":"2022-04-06T15:51:48.122Z","comments":true,"path":"about/index.html","permalink":"https://cwiyc.top/about/index.html","excerpt":"","text":"关于我的一切什么你都想要了解你在说什么"},{"title":"标签","date":"2022-09-24T12:30:41.968Z","updated":"2022-09-24T12:30:41.968Z","comments":false,"path":"tags/index.html","permalink":"https://cwiyc.top/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-18T15:11:08.953Z","updated":"2022-04-18T11:00:35.463Z","comments":false,"path":"repository/index.html","permalink":"https://cwiyc.top/repository/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-24T12:47:09.861Z","updated":"2022-09-24T12:47:09.861Z","comments":true,"path":"links/index.html","permalink":"https://cwiyc.top/links/index.html","excerpt":"","text":"友情链接那些人，那些事 Cwiyc Cwiyc的CSDN Gitee Cwiyc的Gitee仓库 Hexo 快速、簡單且強大的網誌框架 网站值得推荐的网站 Youtube 視頻網站 Weibo 中國最大社交分享平台 Twitter 社交分享平台"},{"title":"分类","date":"2022-09-24T12:31:31.199Z","updated":"2022-09-24T12:31:31.199Z","comments":false,"path":"categories/index.html","permalink":"https://cwiyc.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"docker 部署 vue+springboot前端+后端 整合在一个镜像中","slug":"docker-1","date":"2022-11-17T14:29:21.000Z","updated":"2023-04-16T09:05:16.906Z","comments":true,"path":"2022/11/17/docker-1/","link":"","permalink":"https://cwiyc.top/2022/11/17/docker-1/","excerpt":"如果你自己独立开发了一套前后端分离的项目，想要把它放在一个docker镜像中，一键部署，真正做到开箱即用。 1、什么是dockerbuild once, run everywhere 2、打包前后端文件2.1、打包前端文件1.在项目下执行注意！打包之前你的api不要设置成localhost或者127.0.0.1，而是要换成你等下要部署的服务器的ip地址 123npm run build//oryarn build 2.会生成一个dist文件夹，里面就是你前端所有的代码，等会挂载到nginx服务上 2.2、打包后端文件1.pom.xml里指定打包方式为jar包","text":"如果你自己独立开发了一套前后端分离的项目，想要把它放在一个docker镜像中，一键部署，真正做到开箱即用。 1、什么是dockerbuild once, run everywhere 2、打包前后端文件2.1、打包前端文件1.在项目下执行注意！打包之前你的api不要设置成localhost或者127.0.0.1，而是要换成你等下要部署的服务器的ip地址 123npm run build//oryarn build 2.会生成一个dist文件夹，里面就是你前端所有的代码，等会挂载到nginx服务上 2.2、打包后端文件1.pom.xml里指定打包方式为jar包 1234&lt;project&gt; //意为在project下加入下面这个标签 &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; 2.打包3.打包之后应该会在target下面生成jar包 3、制作docker镜像注意：windows环境下也可以制作镜像，思路都是一样的1.centos7下安装docker 123456789101112131415# 安装依赖（以下是一整条命令）yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2# 设置仓库（以下是一整条命令）yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo# 安装dockeryum install docker-ce docker-ce-cli containerd.io# 启动并加入开机启动systemctl start dockersystemctl enable docker# 验证是否安装成功docker version 2.创建一个文件夹作为你制作镜像的根目录，然后把前后端打包的文件都传进去，可以用filezilla什么的，3.在该目录下创建Dockerfile配置文件，至关重要 1touch Dockerfile 4.编辑Dockerfile 1234567891011121314151617181920212223242526272829303132333435# Docker image for springboot file run# VERSION 0.0.1# Author: cwiyc# 基础镜像FROM centos:8# 维护人信息MAINTAINER cwiyc &lt;cwiyc922@gmail.com&gt;# VOLUME 指定了临时文件目录为/tmp。# 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmpVOLUME /tmp# Centos8于2021年年底停止了服务，所以我们更新yum源为阿里镜像RUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum -y install wgetRUN wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repoRUN yum clean allRUN yum makecache# 安装javaRUN yum -y install java# 安装epel源RUN yum -y install epel-release# 安装nginxRUN yum -y install nginx# 将jar包添加到容器中并更名为app.jarADD orderonlineback-0.0.1-SNAPSHOT.jar app.jar# 把自己本地的html里放的前端项目，放入nginx默认的资源目录里COPY dist /usr/share/nginx/html# 将自己的nginx.conf 配置文件放到docker里nginx默认的配置文件位置COPY nginx.conf /etc/nginx/nginx.conf# 暴露80端口EXPOSE 80# 运行jar包，ENTRYPOINT这条命令只能出现一次，如有多条，则只执行最后一条。该命令只有容器启动时才执行ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 5.在该目录下创建nginx配置文件nginx.conf，这样你可以更灵活的配置nginx。location那个地方的try_files $uri $uri/ /index.html一定要写，默认是没有的，不写的话你刷新页面会404 1touch nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; try_files $uri $uri/ /index.html; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 6.制作镜像 1234// 注意最后的.docker build -t 取个镜像名 .//查看镜像，会出现你刚刚制作的镜像docker images 4、新建一个容器运行镜像提示：每一个镜像都需要运行在一个容器里1.运行容器 12345678# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；# --net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；docker run -itd --name 取个容器名 --net=host 刚刚的镜像名#例如 docker run -itd --name bi43 --net=host backimage41#查看正在运行的容器docker ps 这时后端springboot项目已经运行了，我的是运行在9090查看端口情况 123netstat -ntlp#如果没有这个命令，请安装yum -y install net-tools 2.运行nginx 12docker exec -it 刚刚的容器名 nginx# 例如 docker exec -it bi43 nginx 这时nginx也启动起来了，80端口 5、保存制作好的镜像1.保存镜像的改动 12docker commit 刚刚的容器名 取一个新的镜像名# 例如 docker commit bi43 bir1 此时生成了一个新的镜像，这就是你制作好的镜像。2.阿里托管你的镜像请看这个，push过程稍有些漫长 3.这时候你本地和远程仓库都有你的刚刚制作的镜像了，现在你只需要运行镜像即可(docker exec -it bi43 nginx这条命令还是需要执行来开启nginx) 6、mysql至于mysql，centos7上mysql要付费了，所以要用的mariadb，它在数据的备份和还原上与mysql无痛交流","categories":[{"name":"技术","slug":"技术","permalink":"https://cwiyc.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://cwiyc.top/tags/docker/"}],"author":"Cwiyc"},{"title":"React18实现keepalive效果 react-router-dom@6 outlet 路由页面缓存","slug":"react-keep-alive-router6","date":"2022-11-13T10:47:01.000Z","updated":"2023-04-16T09:08:10.807Z","comments":true,"path":"2022/11/13/react-keep-alive-router6/","link":"","permalink":"https://cwiyc.top/2022/11/13/react-keep-alive-router6/","excerpt":"前言：React18实现keepalive效果 react-router-dom@6 outlet 路由页面缓存注意是实现路由页面的缓存，其他的看官方文档自己摸索，原理都是一样的 1.版本环境123&quot;react&quot;: &quot;^18.2.0&quot;,&quot;react-dom&quot;: &quot;^18.2.0&quot;,&quot;react-router-dom&quot;: &quot;^6.4.2&quot; 按道理版本低一点也没有什么关系。 2.react-activation 这是一个npm包，在react keep alive中用的人数应该是最多的包.这是GitHub地址react-activation 2.1.安装123yarn add react-activation# 或者npm install react-activation 2.2.关闭严格模式在main.tsx里把&lt;React.StrictMode&gt;&lt;/React.StrictMode&gt;这个标签删掉。","text":"前言：React18实现keepalive效果 react-router-dom@6 outlet 路由页面缓存注意是实现路由页面的缓存，其他的看官方文档自己摸索，原理都是一样的 1.版本环境123&quot;react&quot;: &quot;^18.2.0&quot;,&quot;react-dom&quot;: &quot;^18.2.0&quot;,&quot;react-router-dom&quot;: &quot;^6.4.2&quot; 按道理版本低一点也没有什么关系。 2.react-activation 这是一个npm包，在react keep alive中用的人数应该是最多的包.这是GitHub地址react-activation 2.1.安装123yarn add react-activation# 或者npm install react-activation 2.2.关闭严格模式在main.tsx里把&lt;React.StrictMode&gt;&lt;/React.StrictMode&gt;这个标签删掉。 2.3.AliveScope使用一般把AliveScope放在App外层，但是要在Router内层。 2.4.KeepAlive使用在路由表里 12345678910111213141516171819202122232425262728import Login from &quot;../pages/Login&quot;;import Main from &quot;../pages/Main&quot;;import Query from &quot;../pages/Main/Query&quot;;import Index from &quot;../pages/Main/Index/index&quot;;//如果懒加载的话第一次点击不能渲染出组件,要缓存的路由不能懒加载！！// const Query = lazy(() =&gt; import(&quot;../pages/Main/Query&quot;))import KeepAlive from &#x27;react-activation&#x27;const routes: RouteObject[] = [ &#123; path: &#x27;/main&#x27;, element: &lt;Main /&gt;, children: [ &#123; path: &quot;index&quot;, //KeepAlive一定一定要加id！！！ element:&lt;KeepAlive id=&quot;index&quot; &gt;&lt;Index /&gt;&lt;/KeepAlive&gt; &#125;, &#123; path: &quot;query&quot;, element: &lt;KeepAlive id=&quot;query&quot;&gt;&lt;Query /&gt;&lt;/KeepAlive&gt; &#125;, ] &#125;, &#123; path: &#x27;/login&#x27;, element: &lt;Login /&gt; &#125;] KeepAlive标签一定一定要加id！！！要缓存的路由不能懒加载！！! 2.5.Outlet放置正常放就行，该放哪就放哪。我这个就是放在Main组件里，因为我的&lt;Index /&gt;和&lt;Query /&gt;两个子路由都是属于&lt;Main /&gt;的。 3.结束","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://cwiyc.top/tags/React/"}],"author":"Cwiyc"},{"title":"微信公众号早安定时推送、提醒(自由发挥)，无需花钱购买服务器，免费自动推送方法NodeJs，leancloud，serverless(已更新，非常简单)","slug":"singlepush","date":"2022-10-04T08:22:48.000Z","updated":"2023-04-16T09:13:07.458Z","comments":true,"path":"2022/10/04/singlepush/","link":"","permalink":"https://cwiyc.top/2022/10/04/singlepush/","excerpt":"一、申请微信公众号测试号https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index微信扫码登录： 二、让目标扫码关注公众号 三、新增模板这一步可以自由发挥，这里我只弄了一个天气的api，其他的api网上都有。。。这个是我的模板 1234Hi早上好&#123;&#123;city.DATA&#125;&#125; &#123;&#123;textDay.DATA&#125;&#125; &#123;&#123;tempMin.DATA&#125;&#125;°~&#123;&#123;tempMax.DATA&#125;&#125;° 记得打卡","text":"一、申请微信公众号测试号https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index微信扫码登录： 二、让目标扫码关注公众号 三、新增模板这一步可以自由发挥，这里我只弄了一个天气的api，其他的api网上都有。。。这个是我的模板 1234Hi早上好&#123;&#123;city.DATA&#125;&#125; &#123;&#123;textDay.DATA&#125;&#125; &#123;&#123;tempMin.DATA&#125;&#125;°~&#123;&#123;tempMax.DATA&#125;&#125;° 记得打卡 想要获得天气信息，需要调用天气的接口这里推荐 和风天气 注册登录 应用管理-&gt;创建应用-&gt;得到key 城市代码查询https://github.com/qwd/LocationList/blob/master/China-City-List-latest.csv，可以按住Ctrl+F查找 开发版的天气api为https://devapi.qweather.com/v7/weather/3d?location=这里填城市代码&amp;key=刚刚得到的key，下面给一个长沙天心区的例子https://devapi.qweather.com/v7/weather/3d?location=101250108&amp;key=7997019c2b4941beb6c682c3ca 四、使用leancloud部署云函数 进入leancloud官网注册登录 控制台-&gt;创建应用 进入该应用-&gt;云函数-&gt;部署 1.简单版（在线部署） 可实现所有功能，非常简单 4.在线编辑-&gt;创建函数 点击创建函数会出来如上图框框，随便取个名称，然后将以下内容粘上去注意，标有****************的都是自己要改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980let rq = require(&#x27;request-promise&#x27;);const config = &#123; appid: &#x27;****************&#x27;, //对应测试号信息里的appID secret: &#x27;****************&#x27;, //对应测试号信息里的appsecret grant_type: &#x27;client_credential&#x27;, //默认 tousers: [&#x27;****************&#x27;, &#x27;****************&#x27;]//你要推给哪些人的touser，有几个填几个&#125;;function getAccessToken() &#123; const appid = config.appid; const secret = config.secret; const grant_type = config.grant_type; const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=$&#123;grant_type&#125;&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`; rq(url).then(res =&gt; &#123; getWeather(JSON.parse(res).access_token) &#125;).catch(err =&gt; &#123; console.log(&#x27;获取access_token失败,请检查appid和secret&#x27;, err) &#125;)&#125;function getWeather(access_token) &#123; let options = &#123; //刚刚和风天气的api uri: &#x27;https://devapi.qweather.com/v7/weather/3d?location=********&amp;key=***********************&#x27;, gzip: true &#125; rq(options).then( (res) =&gt; &#123; //获取access_token成功后调用发送模板消息的方法 sendTemplateMsg(access_token, JSON.parse(res).daily[0]); &#125;).catch(err =&gt; &#123; console.log(&#x27;获取天气api失败&#x27;, err) &#125;)&#125;function sendTemplateMsg(access_token, res) &#123; const url = `https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=$&#123;access_token&#125;`; //发送模板消息的接口 const requestData = &#123; //发送模板消息的数据 touser: &#x27;&#x27;,//扫过码的人,这里不用填 template_id: &#x27;************************&#x27;,//消息的模板id url: &#x27;http://weixin.qq.com/download&#x27;, topcolor:&#x27;#1ce9e7&#x27;,//标题颜色 //！！！！！！！！！！！！！！ //请注意！模板上面的··.DATA对应的就是下面的值， //！！！！！！！！！！！！！！ data: &#123; city: &#123; value: &#x27;长沙&#x27;, color: &#x27;#91d1f4&#x27; &#125;, textDay: &#123; value: res.textDay, color: &#x27;#47ed52&#x27; &#125;, tempMin: &#123; value: res.tempMin, color: &#x27;#2ed2ea&#x27; &#125;, tempMax: &#123; value: res.tempMax, color: &#x27;#e02d16&#x27; &#125; &#125; &#125;; config.tousers.forEach(item =&gt; &#123; requestData.touser = item let options = &#123; method: &#x27;POST&#x27;, uri: url, body:JSON.stringify(requestData) &#125;; rq(options).then(res =&gt; &#123; console.log(&#x27;模板消息推送成功&#x27;,res) &#125;).catch(err =&gt; &#123; console.log(&#x27;模板消息推送失败&#x27;, err) &#125;) &#125;)&#125;await getAccessToken()return &quot;推送成功，如果没收到推送请打开日志查看问题&quot; 5.创建-&gt;部署-&gt;调用可以点击运行看微信是否能接收得到推送，如果可以则进行下一步，不可以的话就是出问题了，可以上网搜搜解决，也可以来问我… 2.复杂版（本地部署） 之前对leancloud不够了解，所以采用的这个方法，后来发现在线部署内置了request-promise包，所以最好用上面那个简单方法！ ！！！前提是得有node环境！！！ 4. 安装与登录命令行工具选择对应版本，现在一般电脑都是64位的选这个，下载完成点击安装就可以了。5. 随便在哪创建一个文件夹作为项目的目录，在该目录下终端输入 12345//先登录lean login --region cn-n1//创建新项目lean new 项目名称 //比如lean new singlepush//选择nodejs express 你就会得到一个 将cloud.js里的内容替换成如下注意，标有*****的都是自己要改的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const AV = require(&#x27;leanengine&#x27;)const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const axios = require(&#x27;axios&#x27;)const config = &#123; appid: &#x27;***********&#x27;, //对应测试号信息里的appID secret: &#x27;****************&#x27;, //对应测试号信息里的appsecret grant_type: &#x27;client_credential&#x27;, //默认 tousers:[&#x27;****************&#x27;,&#x27;****************&#x27;]//你要推给哪些人的touser，有几个填几个&#125;;/** * Loads all cloud functions under the `functions` directory. */fs.readdirSync(path.join(__dirname, &#x27;functions&#x27;)).forEach(file =&gt; &#123; require(path.join(__dirname, &#x27;functions&#x27;, file))&#125;)/** * A simple cloud function. */AV.Cloud.define(&#x27;singlepush&#x27;, function () &#123; (function getAccessToken() &#123; const appid = config.appid; const secret = config.secret; const grant_type = config.grant_type; const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=$&#123;grant_type&#125;&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`; axios.get(url).then(res =&gt; &#123; if (res.status === 200) &#123; getWeather(res.data.access_token) &#125; else &#123; throw &#x27;获取access_token失败,请检查appid和secret&#x27; &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;)() return &quot;推送成功，应该没问题&quot; function getWeather(access_token) &#123; //刚刚和风天气的api axios.get(&#x27;https://devapi.qweather.com/v7/weather/3d?location=********&amp;key=***********************&#x27;).then((res, res2) =&gt; &#123; sendTemplateMsg(access_token, res.data.daily[0]); //获取access_token成功后调用发送模板消息的方法 &#125;) &#125; function sendTemplateMsg(access_token, res) &#123; const url = `https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=$&#123;access_token&#125;`; //发送模板消息的接口 const requestData = &#123; //发送模板消息的数据 touser: &#x27;&#x27;,//扫过码的人,这里不用填 template_id: &#x27;************&#x27;,//消息的模板id url: &#x27;http://weixin.qq.com/download&#x27;, topcolor:&#x27;#1ce9e7&#x27;,//标题颜色 //！！！！！！！！！！！！！！ //请注意！模板上面的··.DATA对应的就是下面的值， //！！！！！！！！！！！！！！ data: &#123; city: &#123; value: &#x27;长沙&#x27;, color: &#x27;ea2eb7&#x27; //设置字体颜色 &#125;, textDay: &#123;//晴/多云 value: res.textDay, color: &#x27;#91d1f4&#x27; &#125;, tempMin: &#123;//最低温 value: res.tempMin, color: &#x27;#2ed2ea&#x27; &#125;, tempMax: &#123;//最高温 value: res.tempMax, color: &#x27;#e02d16&#x27; &#125; &#125; &#125;; config.tousers.forEach(item =&gt; &#123; requestData.touser = item axios.post(url, requestData).then(res =&gt; &#123; if (res.status === 200) &#123; console.log(&#x27;模板消息推送成功&#x27;); &#125; else &#123; throw &#x27;模板消息推送失败&#x27; &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;) &#125;&#125;) 在项目根目录下终端中输入12npm installnpm install axios@^0.27.2 开始部署1lean deploy --prod 下面是部署成功 成功之后应该会有 可以点击运行看微信是否能接收得到推送，如果可以则进行下一步，不可以的话就是出问题了，可以上网搜搜解决，也可以来问我… 五、创建定时任务创建定时任务，这样可以每天可以定时推送可以先弄一个和现在时间相近的测试一下，没问题就弄正式的 至此，大功告成","categories":[{"name":"闲来无事","slug":"闲来无事","permalink":"https://cwiyc.top/categories/%E9%97%B2%E6%9D%A5%E6%97%A0%E4%BA%8B/"}],"tags":[],"author":"Cwiyc"},{"title":"es6尾调用","slug":"es6尾调用","date":"2022-09-25T02:50:05.000Z","updated":"2022-09-25T02:53:16.989Z","comments":true,"path":"2022/09/25/es6尾调用/","link":"","permalink":"https://cwiyc.top/2022/09/25/es6%E5%B0%BE%E8%B0%83%E7%94%A8/","excerpt":"1.尾调用优化 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。 2.尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120","text":"1.尾调用优化 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。 2.尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 超时Fibonacci(500) // 超时 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。","categories":[{"name":"技术","slug":"技术","permalink":"https://cwiyc.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://cwiyc.top/tags/es6/"}],"author":"Cwiyc"},{"title":"服务器部署vue的另一种姿势","slug":"nginx-2","date":"2022-05-15T01:44:46.000Z","updated":"2022-11-16T15:48:44.719Z","comments":true,"path":"2022/05/15/nginx-2/","link":"","permalink":"https://cwiyc.top/2022/05/15/nginx-2/","excerpt":"服务器部署vue的另一种姿势 上一篇文章我已经讲到了用yarn build或npm run build 的方法将vue项目编译打包生成静态文件dist的方法 这次我们讲一下如何使用yarn serve或npm run serve的方法将本地正在运行的项目暴露给外网访问 1.安装nginx nginx 安装配置nginx的方法我上一篇文章有（已安装请忽略） !!!注意!!! 在终端输入命令之前先输入su，切换到root用户，不然很多操作都用不了 2.安装npm和node2.1.添加NodeSource yum仓库运行以下curl命令 将 NodeSource yum 存储库添加到您的系统 1curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash -","text":"服务器部署vue的另一种姿势 上一篇文章我已经讲到了用yarn build或npm run build 的方法将vue项目编译打包生成静态文件dist的方法 这次我们讲一下如何使用yarn serve或npm run serve的方法将本地正在运行的项目暴露给外网访问 1.安装nginx nginx 安装配置nginx的方法我上一篇文章有（已安装请忽略） !!!注意!!! 在终端输入命令之前先输入su，切换到root用户，不然很多操作都用不了 2.安装npm和node2.1.添加NodeSource yum仓库运行以下curl命令 将 NodeSource yum 存储库添加到您的系统 1curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash - 2.2. 安装 Node.js 和 npm1sudo yum install nodejs 2.3. 验证 Node.js 和 npm 安装12node -vnpm -v 出现版本号则安装成功 2.4配置npm清华镜像 如果不配置的话npm install会很慢 1234#持久配置npm config set registry http://npm.tuna.tsinghua.edu.cn/registry#检查配置是否成功npm config get registry 3.将vue项目传输到服务器 通过filezilla传输或者其他的自行选择 node_modules不要上传，因为服务器和你自己本地的npm环境是不一样的，上传了运行时也会报错，到时候还得老老实实删掉重新npm install. 把项目放在服务器你想放的位置 然后先npm install，再npm run serve 4.配置nginx123#用vim编辑你的nginx.conf#如果你是按我上一篇文章安装的nginx，那么就是如下命令vim /usr/local/nginx/conf/nginx.conf 上面这样配置的意思是用nginx 80端口服务来代理你的localhost:8080端口服务 这时你可以在服务器上的浏览器访问localhost:80访问你的vue项目了 5.防火墙！！！如果在服务器上不需要这一步！，安全组放通端口即可。虚拟机上则需要这一步。！！！ ！！！但是这样在外网是访问不了的，由于服务器防火墙的问题 CentOS7默认使用的是firewall作为防火墙，这里改为iptables防火墙 5.1.关闭firewalld12systemctl stop firewalld systemctl mask firewalld 5.2.使用iptables服务12345678910111213141516171819202122231、安装iptables防火墙yum install iptables-services #安装2、修改文件配置允许80端口vim /etc/sysconfig/iptables #编辑防火墙配置文件按i进入文本编辑 在原文档中找到-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT在该行下面添加-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT:wq! #保存退出#开放443端口(HTTPS)iptables -A INPUT -p tcp --dport 443 -j ACCEPT #保存上述规则service iptables save #开启服务systemctl restart iptables.service#设置防火墙开机启动systemctl enable iptables.service 防火墙参考整合了一下两篇文章 https://blog.csdn.net/XlxfyzsFdblj/article/details/78724434 https://blog.csdn.net/sinat_29821865/article/details/80982250 5.3.重启nginx服务器1/usr/local/nginx/sbin/nginx -s reload 现在你可以在外网输入服务器ip地址访问你的项目了","categories":[{"name":"部署","slug":"部署","permalink":"https://cwiyc.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cwiyc.top/tags/Vue/"}],"author":"Cwiyc"},{"title":"将vue项目部署到服务器上","slug":"nginx-1","date":"2022-05-14T07:20:19.000Z","updated":"2022-11-16T15:45:04.618Z","comments":true,"path":"2022/05/14/nginx-1/","link":"","permalink":"https://cwiyc.top/2022/05/14/nginx-1/","excerpt":"如何将已经写好的vue项目部署到服务器上1.首先你得有一台安装了linux系统的服务器或者虚拟机 我测试使用的是虚拟机上的CentOS 7系统， 虚拟机在这里模拟的是服务器， 虚拟机的安装和下载我就不多掰掰了。 如果是服务器的话，初始配置的时候选择linux系统，Ubuntu和CentOS都行 但Ubuntu一般用来学习linux，而CentOS用作服务器系统的比较多 !!!注意!!! 在终端输入命令之前先输入su，切换到root用户，不然很多操作都用不了 2.使用Xshell 连接虚拟机或者服务器上的系统（非必要）在windows下的Xshell可以远程连接服务器，直接在Xshell里操作系统终端，避免重复进入linux系统的麻烦 这里是Xshell的百度网盘链接 链接：https://pan.baidu.com/s/1nN32a974_Q_IcRGq8cci6Q提取码：0922","text":"如何将已经写好的vue项目部署到服务器上1.首先你得有一台安装了linux系统的服务器或者虚拟机 我测试使用的是虚拟机上的CentOS 7系统， 虚拟机在这里模拟的是服务器， 虚拟机的安装和下载我就不多掰掰了。 如果是服务器的话，初始配置的时候选择linux系统，Ubuntu和CentOS都行 但Ubuntu一般用来学习linux，而CentOS用作服务器系统的比较多 !!!注意!!! 在终端输入命令之前先输入su，切换到root用户，不然很多操作都用不了 2.使用Xshell 连接虚拟机或者服务器上的系统（非必要）在windows下的Xshell可以远程连接服务器，直接在Xshell里操作系统终端，避免重复进入linux系统的麻烦 这里是Xshell的百度网盘链接 链接：https://pan.baidu.com/s/1nN32a974_Q_IcRGq8cci6Q提取码：0922 3.在自己的电脑上下载filezillafilezilla可以将自己本地的文件传输到服务器上，官网下载地址https://filezilla-project.org/download.php?type=server ​ 打卡filezilla，新建一个站点 ​ 协议 SFTP ​ 主机 （在服务器终端输入ifconfig查看ip地址） ​ 端口号 默认22 ​ 用户名 root 这样就连接成功了，右边是服务器的目录结构，把文件拖进去就自动上传了 4.在CentOS 7 上安装Nginx Nginx同Apache一样都是一种WEB服务器。 是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器； Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 4.1.安装编译器以及依赖的库文件1yum -y install make zlib zlib-devel gcc gcc-c++ libtool openssl openssl-devel pcre pcre-devel 4.2.下载nginx并解压nginx-1.21.6.tar.gz这个是nginx的一个版本包而已，可以下载任何一个你想的版本。 1cd /usr/local &amp;&amp; wget http://nginx.org/download/nginx-1.21.6.tar.gz &amp;&amp; tar zxvf nginx-1.21.6.tar.gz 4.3.安装nginx1cd nginx-1.21.6 12配置./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-pcre --with-http_ssl_module 12编译和安装make &amp;&amp; make install 4.4.启动、停止、重启nginx这里的/usr/local/nginx/sbin/nginx是要找到nginx的位置 123/usr/local/nginx/sbin/nginx/usr/local/nginx/sbin/nginx -s stop/usr/local/nginx/sbin/nginx -s reload 此处参考https://www.jianshu.com/p/c051164e4203 5.配置nginx5.1.创建网站根目录先回到根目录 12mkdir /wwwmkdir /html 相当于在根目录下创建了 /www/html 这两级文件 5.2.传输文件将vue项目使用 1yarn build 或者 npm run build 编译打包，会生成一个dist文件夹，将**!里面!**的所有文件通过filezilla放在刚刚创建的/www/html下 5.3.配置nginx文件5.3.1.用vim打开nginx.conf（nginx的配置文件）1vim /usr/local/nginx/conf/nginx.conf 5.3.2.按 i 健进入插入模式将画圈的地方改成这样，注意分号不能少 按ESC退出插入模式 按冒号: 输入wq 保存退出 6.外网访问！！！如果在服务器上不需要这一步！，安全组放通端口即可。虚拟机上则需要这一步。！！！ 如果按照上面这样设置的话只能在服务器里通过localhost访问 我们还需要配置外网访问 注意上图中画圈的上面有个 server_name 将localhost改为你服务器的ip地址，这样就能在外网访问你的web服务器了 如果是虚拟机且用的是NAT模式的话，192.168….这个只能在同一局域网下访问 :wq保存退出 ！！！但是这样还是访问不了，由于服务器防火墙的问题 CentOS7默认使用的是firewall作为防火墙，这里改为iptables防火墙 关闭firewalld 12systemctl stop firewalld systemctl mask firewalld 使用iptables服务 12345678910111213141516171819202122231、安装iptables防火墙yum install iptables-services #安装2、修改文件配置允许80端口vim /etc/sysconfig/iptables #编辑防火墙配置文件按i进入文本编辑 在原文档中找到-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT在该行下面添加-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT:wq! #保存退出#开放443端口(HTTPS)iptables -A INPUT -p tcp --dport 443 -j ACCEPT #保存上述规则service iptables save #开启服务systemctl restart iptables.service#设置防火墙开机启动systemctl enable iptables.service 防火墙参考整合了一下两篇文章 https://blog.csdn.net/XlxfyzsFdblj/article/details/78724434 https://blog.csdn.net/sinat_29821865/article/details/80982250 7.重启nginx服务器1/usr/local/nginx/sbin/nginx -s reload 大功告成在服务器浏览器里输入localhost:80 可进入你的项目 在别的浏览器里输入你设置的ip地址也可进入你的项目","categories":[{"name":"部署","slug":"部署","permalink":"https://cwiyc.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cwiyc.top/tags/Vue/"}],"author":"Cwiyc"},{"title":"解决百度文库等各种文库不能复制的问题","slug":"wenku","date":"2022-04-19T00:31:18.000Z","updated":"2022-11-16T15:22:38.745Z","comments":true,"path":"2022/04/19/wenku/","link":"","permalink":"https://cwiyc.top/2022/04/19/wenku/","excerpt":"1.进入网页按下 F12 按钮进入开发者模式2.点击如图设置按钮 3.将滑轮滑倒最下面将该选项打勾，勾选该选项是禁用本页面的JavaScript（也就是阻止用户与页面交互）。 4.这时你就可以尽情复制该页面内容了以上是chrome浏览器的样式，像edge等浏览器都大同小异，赶紧去教你的室友吧！！！别忘了点个赞 heihei~","text":"1.进入网页按下 F12 按钮进入开发者模式2.点击如图设置按钮 3.将滑轮滑倒最下面将该选项打勾，勾选该选项是禁用本页面的JavaScript（也就是阻止用户与页面交互）。 4.这时你就可以尽情复制该页面内容了以上是chrome浏览器的样式，像edge等浏览器都大同小异，赶紧去教你的室友吧！！！别忘了点个赞 heihei~","categories":[{"name":"小窍门","slug":"小窍门","permalink":"https://cwiyc.top/categories/%E5%B0%8F%E7%AA%8D%E9%97%A8/"}],"tags":[],"author":"Cwiyc"},{"title":"3D旋转木马 HTML+css","slug":"mua","date":"2022-04-07T12:00:18.000Z","updated":"2023-04-16T09:06:35.516Z","comments":true,"path":"2022/04/07/mua/","link":"","permalink":"https://cwiyc.top/2022/04/07/mua/","excerpt":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;旋转木马&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding:0; &#125; body&#123; display: flex; justify-content: center; align-items: center;/*以上三行是旋转木马网页居中*/ height: 100vh;/*高度占网页全部*/ background-color: black; perspective: 900px;/*视距*/ &#125; section&#123; position: relative; width: 300px; height: 200px; cursor: pointer;/*hover时鼠标箭头变手指*/ transform-style: preserve-3d;/*写这个才能实现3d效果*/ animation:rotate 20s linear infinite; &#125; img&#123; width: 300px; height: 200px; &#125; section:hover&#123; animation-play-state: paused;/*hover是旋转木马停止*/ &#125; section div&#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; -webkit-box-reflect:below 15px -webkit-linear-gradient(transparent 10%,rgba(255,255,255,.3)); /*实现倒影 below-倒影在原方块的下方 15px-原方块距离倒影的距离 倒影的10%设置为全透明， rgba设置剩下倒影的透明度*/ &#125; section div:nth-child(1)&#123; transform: translatez(300px);/*函数将元素从屏幕“向外”移动300像素到用户。这使得在2D显示器上观看时元素显得更大，*/ background-color: #c14c39; &#125; section div:nth-child(2)&#123; transform:rotateY(60deg) translatez(300px);/*rotateY表示绕y轴旋转60° */ background-color: #6e9c72; &#125; section div:nth-child(3)&#123; transform:rotateY(120deg) translatez(300px); background-color: #5e5f7a; &#125; section div:nth-child(4)&#123; transform:rotateY(180deg) translatez(300px); background-color: #f5eb98; &#125; section div:nth-child(5)&#123; transform:rotateY(240deg) translatez(300px); background-color: #50a3bc; &#125; section div:nth-child(6)&#123; transform:rotateY(300deg) translatez(300px); background-color: #f9a99a; &#125; @keyframes rotate &#123; to&#123; transform: rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;img src=&quot;img2/1.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/2.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/3.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/4.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/5.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/6.jpg&quot;&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 图片要自己加啊啊啊！效果图视频我不会加。。。有什么问题欢迎大家在评论区讨论！！","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;旋转木马&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding:0; &#125; body&#123; display: flex; justify-content: center; align-items: center;/*以上三行是旋转木马网页居中*/ height: 100vh;/*高度占网页全部*/ background-color: black; perspective: 900px;/*视距*/ &#125; section&#123; position: relative; width: 300px; height: 200px; cursor: pointer;/*hover时鼠标箭头变手指*/ transform-style: preserve-3d;/*写这个才能实现3d效果*/ animation:rotate 20s linear infinite; &#125; img&#123; width: 300px; height: 200px; &#125; section:hover&#123; animation-play-state: paused;/*hover是旋转木马停止*/ &#125; section div&#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; -webkit-box-reflect:below 15px -webkit-linear-gradient(transparent 10%,rgba(255,255,255,.3)); /*实现倒影 below-倒影在原方块的下方 15px-原方块距离倒影的距离 倒影的10%设置为全透明， rgba设置剩下倒影的透明度*/ &#125; section div:nth-child(1)&#123; transform: translatez(300px);/*函数将元素从屏幕“向外”移动300像素到用户。这使得在2D显示器上观看时元素显得更大，*/ background-color: #c14c39; &#125; section div:nth-child(2)&#123; transform:rotateY(60deg) translatez(300px);/*rotateY表示绕y轴旋转60° */ background-color: #6e9c72; &#125; section div:nth-child(3)&#123; transform:rotateY(120deg) translatez(300px); background-color: #5e5f7a; &#125; section div:nth-child(4)&#123; transform:rotateY(180deg) translatez(300px); background-color: #f5eb98; &#125; section div:nth-child(5)&#123; transform:rotateY(240deg) translatez(300px); background-color: #50a3bc; &#125; section div:nth-child(6)&#123; transform:rotateY(300deg) translatez(300px); background-color: #f9a99a; &#125; @keyframes rotate &#123; to&#123; transform: rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;img src=&quot;img2/1.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/2.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/3.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/4.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/5.jpg&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;img2/6.jpg&quot;&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 图片要自己加啊啊啊！效果图视频我不会加。。。有什么问题欢迎大家在评论区讨论！！","categories":[{"name":"html+css","slug":"html-css","permalink":"https://cwiyc.top/categories/html-css/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cwiyc.top/tags/CSS/"}]},{"title":"vue使用scss报错","slug":"website","date":"2022-04-06T15:38:01.000Z","updated":"2023-04-16T09:00:30.548Z","comments":true,"path":"2022/04/06/website/","link":"","permalink":"https://cwiyc.top/2022/04/06/website/","excerpt":"在vue中使用scss需要安装下面三个package 123node-sasssass-loaderstyle-loader 但直接用yarn add node-sass这条命令安装的话，最后会报很多错误。因为这个命令默认安装的是该包的最新版本，node-sass和sass-loader会出现不兼容的问题。所以我们用一下命令指定安装兼容版本 123yarn add node-sass@^4.14.1 --devyarn add sass-loader@^7.3.1 --devyarn add style-loader --dev 这里的- -dev表示安装为开发时依赖像less sass scss 这种预处理器只有在开发的时候才能用到，将整个项目打包后(此时已不再是”开发模式”)，项目里面的样式已经变为css，用户在拿到该项目的包之后执行yarn install时，不会下载package.json里开发依赖的包，只会下载运行依赖的包，减小了负担。","text":"在vue中使用scss需要安装下面三个package 123node-sasssass-loaderstyle-loader 但直接用yarn add node-sass这条命令安装的话，最后会报很多错误。因为这个命令默认安装的是该包的最新版本，node-sass和sass-loader会出现不兼容的问题。所以我们用一下命令指定安装兼容版本 123yarn add node-sass@^4.14.1 --devyarn add sass-loader@^7.3.1 --devyarn add style-loader --dev 这里的- -dev表示安装为开发时依赖像less sass scss 这种预处理器只有在开发的时候才能用到，将整个项目打包后(此时已不再是”开发模式”)，项目里面的样式已经变为css，用户在拿到该项目的包之后执行yarn install时，不会下载package.json里开发依赖的包，只会下载运行依赖的包，减小了负担。","categories":[{"name":"小问题","slug":"小问题","permalink":"https://cwiyc.top/categories/%E5%B0%8F%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cwiyc.top/tags/Vue/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-06T04:37:23.734Z","updated":"2022-04-06T03:26:00.051Z","comments":true,"path":"2022/04/06/hello-world/","link":"","permalink":"https://cwiyc.top/2022/04/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://cwiyc.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"闲来无事","slug":"闲来无事","permalink":"https://cwiyc.top/categories/%E9%97%B2%E6%9D%A5%E6%97%A0%E4%BA%8B/"},{"name":"部署","slug":"部署","permalink":"https://cwiyc.top/categories/%E9%83%A8%E7%BD%B2/"},{"name":"小窍门","slug":"小窍门","permalink":"https://cwiyc.top/categories/%E5%B0%8F%E7%AA%8D%E9%97%A8/"},{"name":"html+css","slug":"html-css","permalink":"https://cwiyc.top/categories/html-css/"},{"name":"小问题","slug":"小问题","permalink":"https://cwiyc.top/categories/%E5%B0%8F%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://cwiyc.top/tags/docker/"},{"name":"React","slug":"React","permalink":"https://cwiyc.top/tags/React/"},{"name":"es6","slug":"es6","permalink":"https://cwiyc.top/tags/es6/"},{"name":"Vue","slug":"Vue","permalink":"https://cwiyc.top/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"https://cwiyc.top/tags/CSS/"}]}